#include <iostream>
using namespace std;


class relation {
private:
	//矩阵，利用指针数组申请二维数组空间
	int** map;
	//求解闭包的结果
	int** ans;
	//矩阵行列，要求行列相同，故仅有一个参数限制
	int M;
	/***************************************************************************
	函数名称：reverse
	功    能：求自反闭包
	输入参数：
	返 回 值：
	说    明：将矩阵对角线的元素都置为1，使得任意x∈A都有<x, x>
	***************************************************************************/
	void reverse() {
		//ans矩阵重置
		reset();
		//对角线都置为1即满足要求
		//使得任意x∈A都有<x, x>
		for (int i = 0; i < M; ++i)
			ans[i][i] = 1;
	}
	/***************************************************************************
	函数名称：symmetry
	功    能：求对称闭包
	输入参数：
	返 回 值：
	说    明：遍历矩阵，将若对称位置为1，则该位置为1
	***************************************************************************/
	void symmetry() {
		//ans矩阵重置
		reset();
		//遍历整个矩阵，若对称位置为1，则该位置也为1
		//使得矩阵的转置等于本身
		/*
		for (int i = 0; i < M; ++i)
			for (int j = 0; j < M; ++j)
				if (map[i][j])
					map[j][i] = 1;
		*/
		//优化版本只遍历下三角，不考虑对角线
		//减少一半的遍历，进行常数的优化
		for (int i = 0; i < M; ++i)
		{
			for (int j = 0; j < i; ++j)
			{
				if (ans[i][j])
					ans[j][i] = 1;
				if (ans[j][i])
					ans[i][j] = 1;
			}
		}
	}
	/***************************************************************************
	函数名称：transition
	功    能：求传递闭包
	输入参数：
	返 回 值：
	说    明：对矩阵进行M(矩阵行列数)次矩阵乘法，所得结果即为传递闭包
	***************************************************************************/
	void transition() {
		//ans矩阵重置
		reset();
		//矩阵相乘需要两个临时矩阵，保存当前的R^k，和结果R^(k + 1)
		//cur数组保存当前R^k
		int** cur = new(nothrow) int*[M];
		if (cur == NULL)
		{
			cerr << "申请空间失败" << endl;
			exit(1);
		}
		for (int i = 0; i < M; ++i) {
			cur[i] = new(nothrow) int[M];
			if (cur[i] == NULL) {
				cerr << "申请空间失败" << endl;
				exit(1);
			}
		}
		//res数组保存运算结果R^(k + 1)
		int** res = new(nothrow) int* [M];
		if (res == NULL)
		{
			cerr << "申请空间失败" << endl;
			exit(1);
		}
		for (int i = 0; i < M; ++i) {
			res[i] = new(nothrow) int[M];
			if (res[i] == NULL) {
				cerr << "申请空间失败" << endl;
				exit(1);
			}
		}
		//将cur赋上初始值，当前cur表示R^1
		for (int i = 0; i < M; ++i)
			for (int j = 0; j < M; ++j)
				cur[i][j] = map[i][j];

		//做M次矩阵相乘
		for (int cnt = 0; cnt < M; ++cnt)
		{
			//行
			for (int i = 0; i < M; ++i)
			{
				//列
				for (int j = 0; j < M; ++j)
				{
					//临时变量保存对i行j列的运算结果
					int temp = 0;
					//cur[i][k]于map[k][j]与运算然后逻辑加
					for (int k = 0; k < M; ++k)
					{
						temp = cur[i][k] && map[k][j];
						//逻辑加表现为，只要有一个是1，结果就是1
						//可以提前退出
						if (temp)
							break;
					}
					res[i][j] = temp;
				}
			}
			//更新cur
			for (int i = 0; i < M; ++i)
				for (int j = 0; j < M; ++j)
				{
					cur[i][j] = res[i][j];
					//更新ans数组，相当于并上R^k
					if (res[i][j])
						ans[i][j] = 1;
				}
		}

		
		//释放空间
		for (int i = 0; i < M; ++i) {
			delete[] cur[i];
			delete[] res[i];
		}
		delete[] cur;
		delete[] res;
	}

	/***************************************************************************
	函数名称：show
	功    能：展示所求关系的矩阵
	输入参数：
	返 回 值：
	说    明：输出的为答案数组
	***************************************************************************/
	void show() {
		cout << "所求关系矩阵为:" << endl;
		for (int i = 0; i < M; ++i)
		{
			for (int j = 0; j < M; ++j)
				cout << ans[i][j] << ' ';
			cout << endl;
		}
	}
	/***************************************************************************
	函数名称：getNM
	功    能：得到矩阵的行数列数
	输入参数：
	返 回 值：
	说    明：矩阵要求行列数相等，因此只需要一个参数限制
	***************************************************************************/
	void getMN() {
		cout << "请输入矩阵的行数:";
		while (1) {
			cin >> M;
			if (cin.fail() || M <= 0) {
				cin.clear();
				cin.ignore(65536, '\n');
				cout << "输入有误，请重新输入正整数" << endl;
			}
			else
				break;
		}

		//根据行列数为矩阵申请相应大小的空间
		map = new(nothrow) int* [M];
		if (map == NULL)
		{
			cerr << "申请空间失败" << endl;
			exit(1);
		}
		ans = new(nothrow) int* [M];
		if (ans == NULL)
		{
			cerr << "申请空间失败" << endl;
			exit(1);
		}
		for (int i = 0; i < M; ++i) {
			map[i] = new(nothrow) int[M];
			if (map[i] == NULL) {
				cerr << "申请空间失败" << endl;
				exit(1);
			}
		}
		for (int i = 0; i < M; ++i) {
			ans[i] = new(nothrow) int[M];
			if (ans[i] == NULL) {
				cerr << "申请空间失败" << endl;
				exit(1);
			}
		}

	}

	/***************************************************************************
	函数名称：getElement
	功    能：得到矩阵内部元素的值
	输入参数：
	返 回 值：
	说    明：每行依次输入，以空格分隔每个元素
				需要进行错误判断，保证元素值只能为0 或 1
	***************************************************************************/
	void getElement() {
		cout << "请输入关系矩阵:" << endl;
		for (int i = 0; i < M; ++i) {
			cout << "请输入矩阵的第" << i << "行元素(元素以空格分隔):";
			for (int j = 0; j < M;)
			{
				cin >> map[i][j];
				if (cin.fail() || !(map[i][j] == 0 || map[i][j] == 1))
				{
					cin.clear();
					cin.ignore(65536, '\n');
					cout << "输入应为0或1" << endl;
				}
				else
				{
					++j;
				}
			}
			cout << endl;
		}
	}

	/***************************************************************************
	函数名称：select
	功    能：用户选择对应算法，输出对应闭包
	输入参数：
	返 回 值：
	说    明：用户可以进行多次选择
	***************************************************************************/
	void select() {
		
		char op = '\0';
		bool loop = true;
		while (loop)
		{
			cout << endl;
			cout << "请输入对应序号选择算法" << endl;
			cout << "1:自反闭包" << endl;
			cout << "2:传递闭包" << endl;
			cout << "3:对称闭包" << endl;
			cout << "4:退出" << endl;
			cin >> op;
			switch (op) {
				case '1':
					this->reverse();
					this->show();
					break;
				case '2':
					this->transition();
					this->show();
					break;
				case '3':
					this->symmetry();
					this->show();
					break;
				case '4':
					loop = false;
					break;
				default:
					cout << "请输入数字[1-4]选择对应操作" << endl;
					cin.clear();
					cin.ignore(65536, '\n');
					break;
			}
		}
	}
	/***************************************************************************
	函数名称：reset
	功    能：将map数组的值赋给ans，即ans重置为原关系矩阵
	输入参数：
	返 回 值：
	说    明：
	***************************************************************************/
	void reset()
	{
		for (int i = 0; i < M; ++i)
			for (int j = 0; j < M; ++j)
				ans[i][j] = map[i][j];
	}

	
public:
	/***************************************************************************
	函数名称：~relation
	功    能：析构函数，释放动态申请的空间
	输入参数：
	返 回 值：
	说    明：
	***************************************************************************/
	~relation() {
		for (int i = 0; i < M; ++i)
			delete[] map[i];

		delete[] map;
	}
	/***************************************************************************
	函数名称：relation
	功    能：构造函数，初始化类的数据成员
	输入参数：
	返 回 值：
	说    明：
	***************************************************************************/
	relation() {
		map = NULL;
		ans = NULL;
		M = 0;
	}

	/***************************************************************************
	函数名称：solution
	功    能：对外接口
	输入参数：
	返 回 值：
	说    明：包括矩阵行列数的设置，元素值的设置，算法的选择
	***************************************************************************/
	void solution() {
		getMN();
		getElement();
		select();
	}
};

int main() {

	relation r;
	r.solution();

	cout << "请输入任意键继续..." << endl;
	cin.get();

	return 0;
}